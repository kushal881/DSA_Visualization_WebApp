<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trees Visualizer - DSA Interactive Learning Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --accent-color: #00ffff;
            --accent-secondary: #ff00ff;
            --tree-node-bg: #2d2d2d;
            --tree-node-border: #00ffff;
            --tree-edge-color: #666;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --card-bg: rgba(26, 26, 26, 0.8);
            --border-color: rgba(0, 255, 255, 0.3);
            --success-color: #00ff88;
            --warning-color: #ffaa00;
            --error-color: #ff4444;
            --highlight-color: #ff6b6b;
            --visited-color: #4ecdc4;
            --current-color: #ffe66d;
        }

        [data-theme="light"] {
            --primary-bg: #f0f0f0;
            --secondary-bg: #ffffff;
            --accent-color: #0066cc;
            --accent-secondary: #cc0066;
            --tree-node-bg: #ffffff;
            --tree-node-border: #0066cc;
            --tree-edge-color: #999;
            --text-primary: #333333;
            --text-secondary: #666666;
            --card-bg: rgba(255, 255, 255, 0.9);
            --border-color: rgba(0, 102, 204, 0.3);
            --success-color: #00aa44;
            --warning-color: #cc8800;
            --error-color: #cc2222;
            --highlight-color: #e74c3c;
            --visited-color: #2ecc71;
            --current-color: #f39c12;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            overflow-x: hidden;
            transition: all 0.3s ease;
        }

        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, 
                rgba(0, 255, 255, 0.05) 0%, 
                rgba(255, 0, 255, 0.05) 25%, 
                rgba(0, 255, 127, 0.05) 50%, 
                rgba(255, 127, 0, 0.05) 75%, 
                rgba(127, 0, 255, 0.05) 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            z-index: -1;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .nav-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--accent-color), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-links a {
            color: var(--text-primary);
            text-decoration: none;
            transition: all 0.3s ease;
            position: relative;
            padding: 0.5rem 1rem;
            border-radius: 8px;
        }

        .nav-links a:hover, .nav-links a.active {
            background: rgba(0, 255, 255, 0.1);
            transform: translateY(-2px);
            color: var(--accent-color);
        }

        .theme-toggle {
            background: none;
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            padding: 0.5rem 1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--accent-color);
            color: var(--primary-bg);
            transform: scale(1.05);
        }

        .main-content {
            margin-top: 80px;
            padding: 2rem;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }

        .page-header {
            text-align: center;
            padding: 2rem 0;
            margin-bottom: 2rem;
        }

        .page-header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--accent-color), var(--accent-secondary), var(--success-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .page-header p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .main-panel {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 2rem;
            min-height: 600px;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .control-panel {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 1.5rem;
        }

        .algorithm-selector {
            margin-bottom: 1.5rem;
        }

        .algorithm-selector h3 {
            margin-bottom: 1rem;
            color: var(--accent-color);
        }

        .algorithm-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--accent-color), var(--accent-secondary));
            color: white;
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }

        .btn:active {
            background: var(--accent-color);
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--secondary-bg);
            color: var(--text-primary);
            font-size: 1rem;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 255, 255, 0.1);
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .tree-visualization {
            width: 100%;
            height: 500px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            background: var(--secondary-bg);
            position: relative;
            overflow: hidden;
        }

        .tree-canvas {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .tree-node {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 3px solid var(--tree-node-border);
            border-radius: 50%;
            background: var(--tree-node-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            user-select: none;
        }

        .tree-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .tree-node.current {
            border-color: var(--current-color);
            background: var(--current-color);
            color: var(--primary-bg);
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(255, 230, 109, 0.7);
        }

        .tree-node.visited {
            border-color: var(--visited-color);
            background: var(--visited-color);
            color: var(--primary-bg);
        }

        .tree-node.highlight {
            border-color: var(--highlight-color);
            background: var(--highlight-color);
            color: white;
            animation: nodeHighlight 0.5s ease;
        }

        @keyframes nodeHighlight {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        .tree-edge {
            position: absolute;
            background: var(--tree-edge-color);
            transform-origin: left center;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .tree-edge.active {
            background: var(--accent-color);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .traversal-path {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .traversal-path h4 {
            margin-bottom: 0.5rem;
            color: var(--accent-color);
        }

        .path-display {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        .path-node {
            padding: 0.5rem 1rem;
            background: var(--accent-color);
            color: var(--primary-bg);
            border-radius: 20px;
            font-weight: bold;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .path-arrow {
            color: var(--accent-color);
            font-size: 1.2rem;
        }

        .algorithm-info {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .algorithm-info h3 {
            margin-bottom: 0.5rem;
            color: var(--accent-color);
        }

        .algorithm-info p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .complexity-badges {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .complexity-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .complexity-time {
            background: rgba(0, 255, 255, 0.2);
            color: var(--accent-color);
        }

        .complexity-space {
            background: rgba(255, 0, 255, 0.2);
            color: var(--accent-secondary);
        }

        .code-section {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .code-section h3 {
            margin-bottom: 1rem;
            color: var(--accent-color);
        }

        .code-display {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 400px;
            overflow-y: auto;
        }

        .code-line {
            padding: 0.25rem 0;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .code-line.active {
            background: rgba(0, 255, 255, 0.1);
            border-left: 4px solid var(--accent-color);
            padding-left: 1rem;
        }

        .notes-section {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 1.5rem;
        }

        .notes-section h3 {
            margin-bottom: 1rem;
            color: var(--accent-color);
        }

        .notes-textarea {
            width: 100%;
            height: 200px;
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem;
            color: var(--text-primary);
            font-family: inherit;
            resize: vertical;
            font-size: 0.9rem;
        }

        .notes-textarea:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 255, 255, 0.1);
        }

        .notes-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .speed-slider {
            flex: 1;
            height: 5px;
            background: var(--border-color);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
        }

        .status-bar {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: var(--accent-color);
            border-radius: 50%;
            animation: float 8s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 0;
            }
        }

        @media (max-width: 1024px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
            
            .side-panel {
                grid-row: 1;
            }
            
            .main-panel {
                grid-row: 2;
            }
        }

        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }
            
            .algorithm-buttons {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .tree-node {
                width: 40px;
                height: 40px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body data-theme="dark">
    <div class="animated-bg"></div>
    <div class="floating-particles"></div>
    
    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html" class="logo">DSA Visualizer</a>
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="sorting.html">Sorting</a></li>
                <li><a href="searching.html">Searching</a></li>
                <li><a href="trees.html" class="active">Trees</a></li>
                <li><a href="graphs.html">Graphs</a></li>
                <li><a href="notes.html">Notes</a></li>
            </ul>
            <button class="theme-toggle" onclick="toggleTheme()">🌙</button>
        </div>
    </nav>

    <main class="main-content">
        <div class="page-header">
            <h1>Tree Data Structures</h1>
            <p>Explore hierarchical data structures with interactive visualizations</p>
        </div>

        <div class="content-grid">
            <div class="main-panel">
                <h2>Tree Visualization</h2>
                <div class="tree-visualization" id="tree-visualization">
                    <div class="tree-canvas" id="tree-canvas"></div>
                </div>
                
                <div class="traversal-path" id="traversal-path" style="display: none;">
                    <h4>Traversal Path</h4>
                    <div class="path-display" id="path-display"></div>
                </div>

                <div class="status-bar">
                    <div class="status-text" id="status-text">Ready - Select an algorithm to begin</div>
                    <div class="status-text" id="node-count">Nodes: 0</div>
                </div>
            </div>

            <div class="side-panel">
                <div class="control-panel">
                    <div class="algorithm-selector">
                        <h3>Tree Operations</h3>
                        <div class="algorithm-buttons">
                            <button class="btn btn-primary btn-small" onclick="selectAlgorithm('insert')">Insert</button>
                            <button class="btn btn-primary btn-small" onclick="selectAlgorithm('delete')">Delete</button>
                            <button class="btn btn-primary btn-small" onclick="selectAlgorithm('search')">Search</button>
                            <button class="btn btn-primary btn-small" onclick="selectAlgorithm('clear')">Clear</button>
                        </div>
                    </div>

                    <div class="algorithm-selector">
                        <h3>Traversal Algorithms</h3>
                        <div class="algorithm-buttons">
                            <button class="btn btn-secondary btn-small" onclick="selectAlgorithm('inorder')">Inorder</button>
                            <button class="btn btn-secondary btn-small" onclick="selectAlgorithm('preorder')">Preorder</button>
                            <button class="btn btn-secondary btn-small" onclick="selectAlgorithm('postorder')">Postorder</button>
                            <button class="btn btn-secondary btn-small" onclick="selectAlgorithm('levelorder')">Level Order</button>
                        </div>
                    </div>

                    <div class="input-group">
                        <label for="node-value">Node Value</label>
                        <input type="number" id="node-value" placeholder="Enter value...">
                    </div>

                    <div class="controls">
                        <button class="btn btn-primary" onclick="executeOperation()" id="execute-btn">Execute</button>
                        <button class="btn btn-secondary" onclick="pauseAnimation()" id="pause-btn">Pause</button>
                        <button class="btn btn-secondary" onclick="resetAnimation()" id="reset-btn">Reset</button>
                    </div>

                    <div class="speed-control">
                        <label>Speed:</label>
                        <input type="range" class="speed-slider" min="1" max="10" value="5" id="speed-slider">
                        <span id="speed-value">5</span>
                    </div>

                    <div class="controls">
                        <button class="btn btn-secondary btn-small" onclick="generateSampleTree()">Sample Tree</button>
                        <button class="btn btn-secondary btn-small" onclick="generateRandomTree()">Random Tree</button>
                    </div>
                </div>

                <div class="algorithm-info" id="algorithm-info">
                    <h3>Select an Algorithm</h3>
                    <p>Choose a tree operation or traversal algorithm to see detailed information and visualization.</p>
                </div>
            </div>
        </div>

        <div class="code-section">
            <h3>Algorithm Implementation</h3>
            <div class="code-display" id="code-display">
                <div class="code-line">// Select an algorithm to see its implementation</div>
                <div class="code-line">// The active line will be highlighted during execution</div>
            </div>
        </div>

        <div class="notes-section">
            <h3>Personal Notes</h3>
            <textarea class="notes-textarea" id="notes-textarea" placeholder="Write your notes about tree algorithms here..."></textarea>
            <div class="notes-controls">
                <button class="btn btn-primary" onclick="saveNotes()">Save Notes</button>
                <button class="btn btn-secondary" onclick="clearNotes()">Clear Notes</button>
                <button class="btn btn-secondary" onclick="exportNotes()">Export Notes</button>
            </div>
        </div>
    </main>

    <script>
        // Global variables
        let currentAlgorithm = null;
        let isAnimating = false;
        let animationSpeed = 500;
        let treeRoot = null;
        let nodeCounter = 0;
        let traversalPath = [];
        let animationQueue = [];
        let currentAnimationIndex = 0;

        // Tree Node class
        class TreeNode {
            constructor(value, x = 0, y = 0) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = x;
                this.y = y;
                this.id = `node-${nodeCounter++}`;
                this.element = null;
            }
        }

        // Binary Search Tree class
        class BinarySearchTree {
            constructor() {
                this.root = null;
            }

            insert(value) {
                const newNode = new TreeNode(value);
                if (!this.root) {
                    this.root = newNode;
                    this.root.x = 400;
                    this.root.y = 50;
                } else {
                    this.insertNode(this.root, newNode);
                }
                return newNode;
            }

            insertNode(node, newNode) {
                if (newNode.value < node.value) {
                    if (!node.left) {
                        node.left = newNode;
                        newNode.x = node.x - 80;
                        newNode.y = node.y + 80;
                    } else {
                        this.insertNode(node.left, newNode);
                    }
                } else {
                    if (!node.right) {
                        node.right = newNode;
                        newNode.x = node.x + 80;
                        newNode.y = node.y + 80;
                    } else {
                        this.insertNode(node.right, newNode);
                    }
                }
            }

            search(value) {
                return this.searchNode(this.root, value);
            }

            searchNode(node, value) {
                if (!node) return null;
                if (value === node.value) return node;
                if (value < node.value) return this.searchNode(node.left, value);
                return this.searchNode(node.right, value);
            }

            delete(value) {
                this.root = this.deleteNode(this.root, value);
            }

            deleteNode(node, value) {
                if (!node) return null;

                if (value < node.value) {
                    node.left = this.deleteNode(node.left, value);
                } else if (value > node.value) {
                    node.right = this.deleteNode(node.right, value);
                } else {
                    // Node to be deleted found
                    if (!node.left && !node.right) {
                        return null;
                    }
                    if (!node.left) return node.right;
                    if (!node.right) return node.left;

                    // Node with two children
                    const minRight = this.findMin(node.right);
                    node.value = minRight.value;
                    node.right = this.deleteNode(node.right, minRight.value);
                }
                return node;
            }

            findMin(node) {
                while (node.left) {
                    node = node.left;
                }
                return node;
            }

            inorderTraversal(node = this.root, result = []) {
                if (node) {
                    this.inorderTraversal(node.left, result);
                    result.push(node);
                    this.inorderTraversal(node.right, result);
                }
                return result;
            }

            preorderTraversal(node = this.root, result = []) {
                if (node) {
                    result.push(node);
                    this.preorderTraversal(node.left, result);
                    this.preorderTraversal(node.right, result);
                }
                return result;
            }

            postorderTraversal(node = this.root, result = []) {
                if (node) {
                    this.postorderTraversal(node.left, result);
                    this.postorderTraversal(node.right, result);
                    result.push(node);
                }
                return result;
            }

            levelOrderTraversal() {
                if (!this.root) return [];
                const result = [];
                const queue = [this.root];
                
                while (queue.length > 0) {
                    const node = queue.shift();
                    result.push(node);
                    
                    if (node.left) queue.push(node.left);
                    if (node.right) queue.push(node.right);
                }
                
                return result;
            }
        }

        // Initialize BST
        let bst = new BinarySearchTree();

        // Theme toggle
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);
            
            const toggleButton = document.querySelector('.theme-toggle');
            toggleButton.textContent = newTheme === 'dark' ? '🌙' : '☀️';
        }

        // Create floating particles
        function createParticles() {
            const particleContainer = document.querySelector('.floating-particles');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 8 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 5) + 's';
                particleContainer.appendChild(particle);
            }
        }

        // Initialize particles
        createParticles();

        // Algorithm information
        const algorithmInfo = {
            insert: {
                title: "BST Insert",
                description: "Insert a new node into the binary search tree while maintaining the BST property.",
                timeComplexity: "O(log n) average, O(n) worst",
                spaceComplexity: "O(1)"
            },
            delete: {
                title: "BST Delete",
                description: "Remove a node from the binary search tree while maintaining the BST property.",
                timeComplexity: "O(log n) average, O(n) worst",
                spaceComplexity: "O(1)"
            },
            search: {
                title: "BST Search",
                description: "Find a specific value in the binary search tree.",
                timeComplexity: "O(log n) average, O(n) worst",
                spaceComplexity: "O(1)"
            },
            inorder: {
                title: "Inorder Traversal",
                description: "Visit nodes in Left-Root-Right order. Results in sorted order for BST.",
                timeComplexity: "O(n)",
                spaceComplexity: "O(h) where h is height"
            },
            preorder: {
                title: "Preorder Traversal",
                description: "Visit nodes in Root-Left-Right order. Useful for creating a copy of the tree.",
                timeComplexity: "O(n)",
                spaceComplexity: "O(h) where h is height"
            },
            postorder: {
                title: "Postorder Traversal",
                description: "Visit nodes in Left-Right-Root order. Useful for deleting the tree.",
                timeComplexity: "O(n)",
                spaceComplexity: "O(h) where h is height"
            },
            levelorder: {
                title: "Level Order Traversal",
                description: "Visit nodes level by level from top to bottom, left to right.",
                timeComplexity: "O(n)",
                spaceComplexity: "O(w) where w is max width"
            }
        };

        // Algorithm code snippets
        const algorithmCode = {
            insert: `
function insert(value) {
    const newNode = new TreeNode(value);
    if (!this.root) {
        this.root = newNode;
        return newNode;
    }
    return this.insertNode(this.root, newNode);
}

function insertNode(node, newNode) {
    if (newNode.value < node.value) {
        if (!node.left) {
            node.left = newNode;
        } else {
            this.insertNode(node.left, newNode);
        }
    } else {
        if (!node.right) {
            node.right = newNode;
        } else {
            this.insertNode(node.right, newNode);
        }
    }
}`,
            delete: `
function deleteNode(node, value) {
    if (!node) return null;
    
    if (value < node.value) {
        node.left = this.deleteNode(node.left, value);
    } else if (value > node.value) {
        node.right = this.deleteNode(node.right, value);
    } else {
        // Node to be deleted found
        if (!node.left && !node.right) {
            return null;
        }
        if (!node.left) return node.right;
        if (!node.right) return node.left;
        
        // Node with two children
        const minRight = this.findMin(node.right);
        node.value = minRight.value;
        node.right = this.deleteNode(node.right, minRight.value);
    }
    return node;
}`,
            search: `
function search(value) {
    return this.searchNode(this.root, value);
}

function searchNode(node, value) {
    if (!node) return null;
    
    if (value === node.value) {
        return node;
    }
    
    if (value < node.value) {
        return this.searchNode(node.left, value);
    }
    
    return this.searchNode(node.right, value);
}`,
            inorder: `
function inorderTraversal(node, result = []) {
    if (node) {
        this.inorderTraversal(node.left, result);
        result.push(node.value);
        this.inorderTraversal(node.right, result);
    }
    return result;
}

// Usage: Left -> Root -> Right
// For BST, this gives sorted order`,
            preorder: `
function preorderTraversal(node, result = []) {
    if (node) {
        result.push(node.value);
        this.preorderTraversal(node.left, result);
        this.preorderTraversal(node.right, result);
    }
    return result;
}

// Usage: Root -> Left -> Right
// Useful for creating tree copy`,
            postorder: `
function postorderTraversal(node, result = []) {
    if (node) {
        this.postorderTraversal(node.left, result);
        this.postorderTraversal(node.right, result);
        result.push(node.value);
    }
    return result;
}

// Usage: Left -> Right -> Root
// Useful for deleting tree`,
            levelorder: `
function levelOrderTraversal() {
    if (!this.root) return [];
    
    const result = [];
    const queue = [this.root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node.value);
        
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }
    
    return result;
}`
        };

        // Select algorithm
        function selectAlgorithm(algorithm) {
            currentAlgorithm = algorithm;
            updateAlgorithmInfo();
            updateCodeDisplay();
            updateUI();
        }

        // Update algorithm information
        function updateAlgorithmInfo() {
            const infoPanel = document.getElementById('algorithm-info');
            if (currentAlgorithm && algorithmInfo[currentAlgorithm]) {
                const info = algorithmInfo[currentAlgorithm];
                infoPanel.innerHTML = `
                    <h3>${info.title}</h3>
                    <p>${info.description}</p>
                    <div class="complexity-badges">
                        <span class="complexity-badge complexity-time">Time: ${info.timeComplexity}</span>
                        <span class="complexity-badge complexity-space">Space: ${info.spaceComplexity}</span>
                    </div>
                `;
            }
        }

        // Update code display
        function updateCodeDisplay() {
            const codeDisplay = document.getElementById('code-display');
            if (currentAlgorithm && algorithmCode[currentAlgorithm]) {
                const code = algorithmCode[currentAlgorithm];
                const lines = code.trim().split('\n');
                codeDisplay.innerHTML = lines.map(line => 
                    `<div class="code-line">${line}</div>`
                ).join('');
            }
        }

        // Update UI based on current algorithm
        function updateUI() {
            const executeBtn = document.getElementById('execute-btn');
            const nodeValueInput = document.getElementById('node-value');
            
            if (currentAlgorithm) {
                executeBtn.disabled = false;
                if (['insert', 'delete', 'search'].includes(currentAlgorithm)) {
                    nodeValueInput.style.display = 'block';
                    nodeValueInput.previousElementSibling.style.display = 'block';
                } else {
                    nodeValueInput.style.display = 'none';
                    nodeValueInput.previousElementSibling.style.display = 'none';
                }
            }
        }

        // Execute operation
        function executeOperation() {
            if (!currentAlgorithm) return;
            
            const nodeValue = parseInt(document.getElementById('node-value').value);
            
            switch (currentAlgorithm) {
                case 'insert':
                    if (isNaN(nodeValue)) {
                        alert('Please enter a valid number');
                        return;
                    }
                    animateInsert(nodeValue);
                    break;
                case 'delete':
                    if (isNaN(nodeValue)) {
                        alert('Please enter a valid number');
                        return;
                    }
                    animateDelete(nodeValue);
                    break;
                case 'search':
                    if (isNaN(nodeValue)) {
                        alert('Please enter a valid number');
                        return;
                    }
                    animateSearch(nodeValue);
                    break;
                case 'inorder':
                    animateTraversal('inorder');
                    break;
                case 'preorder':
                    animateTraversal('preorder');
                    break;
                case 'postorder':
                    animateTraversal('postorder');
                    break;
                case 'levelorder':
                    animateTraversal('levelorder');
                    break;
                case 'clear':
                    clearTree();
                    break;
            }
        }

        // Animate insert operation
        function animateInsert(value) {
            if (isAnimating) return;
            
            isAnimating = true;
            updateStatus('Inserting node...');
            
            const newNode = bst.insert(value);
            renderTree();
            
            // Animate the insertion path
            const path = findInsertionPath(bst.root, value);
            animateNodePath(path, () => {
                highlightNode(newNode, 'highlight');
                updateStatus('Node inserted successfully');
                isAnimating = false;
                updateNodeCount();
            });
        }

        // Animate delete operation
        function animateDelete(value) {
            if (isAnimating) return;
            
            const nodeToDelete = bst.search(value);
            if (!nodeToDelete) {
                updateStatus('Node not found');
                return;
            }
            
            isAnimating = true;
            updateStatus('Deleting node...');
            
            // Animate search path first
            const path = findSearchPath(bst.root, value);
            animateNodePath(path, () => {
                highlightNode(nodeToDelete, 'highlight');
                setTimeout(() => {
                    bst.delete(value);
                    renderTree();
                    updateStatus('Node deleted successfully');
                    isAnimating = false;
                    updateNodeCount();
                }, animationSpeed);
            });
        }

        // Animate search operation
        function animateSearch(value) {
            if (isAnimating) return;
            
            isAnimating = true;
            updateStatus('Searching for node...');
            
            const targetNode = bst.search(value);
            const path = findSearchPath(bst.root, value);
            
            animateNodePath(path, () => {
                if (targetNode) {
                    highlightNode(targetNode, 'highlight');
                    updateStatus('Node found!');
                } else {
                    updateStatus('Node not found');
                }
                isAnimating = false;
            });
        }

        // Animate traversal
        function animateTraversal(type) {
            if (isAnimating) return;
            
            isAnimating = true;
            updateStatus(`Performing ${type} traversal...`);
            
            let nodes;
            switch (type) {
                case 'inorder':
                    nodes = bst.inorderTraversal();
                    break;
                case 'preorder':
                    nodes = bst.preorderTraversal();
                    break;
                case 'postorder':
                    nodes = bst.postorderTraversal();
                    break;
                case 'levelorder':
                    nodes = bst.levelOrderTraversal();
                    break;
            }
            
            traversalPath = [];
            const pathDisplay = document.getElementById('path-display');
            pathDisplay.innerHTML = '';
            document.getElementById('traversal-path').style.display = 'block';
            
            animateTraversalPath(nodes, 0, () => {
                updateStatus(`${type} traversal completed`);
                isAnimating = false;
            });
        }

        // Find insertion path
        function findInsertionPath(node, value, path = []) {
            if (!node) return path;
            
            path.push(node);
            
            if (value < node.value) {
                if (node.left) {
                    return findInsertionPath(node.left, value, path);
                }
            } else {
                if (node.right) {
                    return findInsertionPath(node.right, value, path);
                }
            }
            
            return path;
        }

        // Find search path
        function findSearchPath(node, value, path = []) {
            if (!node) return path;
            
            path.push(node);
            
            if (value === node.value) {
                return path;
            }
            
            if (value < node.value) {
                return findSearchPath(node.left, value, path);
            } else {
                return findSearchPath(node.right, value, path);
            }
        }

        // Animate node path
        function animateNodePath(path, callback) {
            if (path.length === 0) {
                callback();
                return;
            }
            
            let index = 0;
            const animateNext = () => {
                if (index < path.length) {
                    highlightNode(path[index], 'current');
                    setTimeout(() => {
                        if (index > 0) {
                            highlightNode(path[index - 1], 'visited');
                        }
                        index++;
                        animateNext();
                    }, animationSpeed);
                } else {
                    callback();
                }
            };
            
            animateNext();
        }

        // Animate traversal path
        function animateTraversalPath(nodes, index, callback) {
            if (index >= nodes.length) {
                callback();
                return;
            }
            
            const node = nodes[index];
            highlightNode(node, 'current');
            
            // Add to path display
            const pathDisplay = document.getElementById('path-display');
            const nodeElement = document.createElement('div');
            nodeElement.className = 'path-node';
            nodeElement.textContent = node.value;
            pathDisplay.appendChild(nodeElement);
            
            if (index < nodes.length - 1) {
                const arrow = document.createElement('div');
                arrow.className = 'path-arrow';
                arrow.textContent = '→';
                pathDisplay.appendChild(arrow);
            }
            
            setTimeout(() => {
                highlightNode(node, 'visited');
                animateTraversalPath(nodes, index + 1, callback);
            }, animationSpeed);
        }

        // Highlight node
        function highlightNode(node, className) {
            if (node && node.element) {
                node.element.className = `tree-node ${className}`;
            }
        }

        // Clear all node highlights
        function clearHighlights() {
            const nodes = document.querySelectorAll('.tree-node');
            nodes.forEach(node => {
                node.className = 'tree-node';
            });
        }

        // Render tree
        function renderTree() {
            const canvas = document.getElementById('tree-canvas');
            canvas.innerHTML = '';
            
            if (!bst.root) return;
            
            // Calculate positions
            calculateNodePositions(bst.root);
            
            // Render edges first
            renderEdges(bst.root, canvas);
            
            // Render nodes
            renderNodes(bst.root, canvas);
            
            updateNodeCount();
        }

        // Calculate node positions
        function calculateNodePositions(node, depth = 0) {
            if (!node) return;
            
            const canvasWidth = 800;
            const canvasHeight = 500;
            const levelHeight = 80;
            
            // Calculate horizontal position based on inorder traversal
            const inorderNodes = bst.inorderTraversal();
            const nodeIndex = inorderNodes.indexOf(node);
            const nodeSpacing = canvasWidth / (inorderNodes.length + 1);
            
            node.x = nodeSpacing * (nodeIndex + 1);
            node.y = 60 + depth * levelHeight;
            
            if (node.left) {
                calculateNodePositions(node.left, depth + 1);
            }
            if (node.right) {
                calculateNodePositions(node.right, depth + 1);
            }
        }

        // Render edges
        function renderEdges(node, canvas) {
            if (!node) return;
            
            if (node.left) {
                const edge = createEdge(node.x, node.y, node.left.x, node.left.y);
                canvas.appendChild(edge);
                renderEdges(node.left, canvas);
            }
            
            if (node.right) {
                const edge = createEdge(node.x, node.y, node.right.x, node.right.y);
                canvas.appendChild(edge);
                renderEdges(node.right, canvas);
            }
        }

        // Create edge element
        function createEdge(x1, y1, x2, y2) {
            const edge = document.createElement('div');
            edge.className = 'tree-edge';
            
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            edge.style.width = length + 'px';
            edge.style.height = '2px';
            edge.style.left = (x1 + 25) + 'px';
            edge.style.top = (y1 + 25) + 'px';
            edge.style.transform = `rotate(${angle}deg)`;
            
            return edge;
        }

        // Render nodes
        function renderNodes(node, canvas) {
            if (!node) return;
            
            const nodeElement = document.createElement('div');
            nodeElement.className = 'tree-node';
            nodeElement.textContent = node.value;
            nodeElement.style.left = node.x + 'px';
            nodeElement.style.top = node.y + 'px';
            nodeElement.onclick = () => selectNode(node);
            
            node.element = nodeElement;
            canvas.appendChild(nodeElement);
            
            if (node.left) {
                renderNodes(node.left, canvas);
            }
            if (node.right) {
                renderNodes(node.right, canvas);
            }
        }

        // Select node
        function selectNode(node) {
            if (isAnimating) return;
            
            document.getElementById('node-value').value = node.value;
            highlightNode(node, 'highlight');
            
            setTimeout(() => {
                clearHighlights();
            }, 1000);
        }

        // Generate sample tree
        function generateSampleTree() {
            bst = new BinarySearchTree();
            const values = [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45];
            
            values.forEach(value => {
                bst.insert(value);
            });
            
            renderTree();
            updateStatus('Sample tree generated');
        }

        // Generate random tree
        function generateRandomTree() {
            bst = new BinarySearchTree();
            const nodeCount = Math.floor(Math.random() * 10) + 5;
            const values = new Set();
            
            while (values.size < nodeCount) {
                values.add(Math.floor(Math.random() * 100) + 1);
            }
            
            Array.from(values).forEach(value => {
                bst.insert(value);
            });
            
            renderTree();
            updateStatus('Random tree generated');
        }

        // Clear tree
        function clearTree() {
            bst = new BinarySearchTree();
            renderTree();
            clearHighlights();
            document.getElementById('traversal-path').style.display = 'none';
            updateStatus('Tree cleared');
        }

        // Update status
        function updateStatus(message) {
            document.getElementById('status-text').textContent = message;
        }

        // Update node count
        function updateNodeCount() {
            const count = bst.inorderTraversal().length;
            document.getElementById('node-count').textContent = `Nodes: ${count}`;
        }

        // Pause animation
        function pauseAnimation() {
            isAnimating = false;
            updateStatus('Animation paused');
        }

        // Reset animation
        function resetAnimation() {
            isAnimating = false;
            clearHighlights();
            document.getElementById('traversal-path').style.display = 'none';
            updateStatus('Animation reset');
        }

        // Speed control
        document.getElementById('speed-slider').addEventListener('input', (e) => {
            const speed = parseInt(e.target.value);
            animationSpeed = 1100 - (speed * 100);
            document.getElementById('speed-value').textContent = speed;
        });

        // Notes functionality
        function saveNotes() {
            const notes = document.getElementById('notes-textarea').value;
            localStorage.setItem('tree-notes', notes);
            alert('Notes saved successfully!');
        }

        function clearNotes() {
            document.getElementById('notes-textarea').value = '';
            localStorage.removeItem('tree-notes');
            alert('Notes cleared!');
        }

        function exportNotes() {
            const notes = document.getElementById('notes-textarea').value;
            const blob = new Blob([notes], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tree-notes.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Load saved notes
        function loadNotes() {
            const savedNotes = localStorage.getItem('tree-notes');
            if (savedNotes) {
                document.getElementById('notes-textarea').value = savedNotes;
            }
        }

        // Initialize
        function init() {
            loadNotes();
            generateSampleTree();
            updateStatus('Ready - Select an algorithm to begin');
        }

        // Start the application
        init();
    </script>
</body>
</html>